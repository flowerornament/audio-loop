---
phase: 5.1-cli-iterate-command
plan: 01
type: execute
---

<objective>
Add `audioloop iterate` command for single-command render→analyze→play workflow with inline SC code support.

Purpose: Reduce orchestration overhead from multiple tool calls (render, analyze, play) to single unified command. Real-world testing revealed process startup and tool call latency exceeds actual computation time.
Output: Working `iterate` command that accepts inline SC code or file path, returns combined JSON with render + analysis results.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-performance-optimization/05-01-SUMMARY.md

# Relevant source files:
@src/audioloop/cli.py
@src/audioloop/render.py
@src/audioloop/analyze.py
@src/audioloop/play.py
@src/audioloop/wrapper.py

**Tech stack available:** typer, rich, librosa, MoSQITo
**Established patterns:** typer CLI with JSON/human output modes, dataclass results, error handling via custom exceptions

**Prior decision (Phase 5):** Serial computation retained; --no-psychoacoustic flag for fast analysis (~15ms vs ~1100ms)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add iterate command with inline SC code support</name>
  <files>src/audioloop/cli.py, src/audioloop/render.py</files>
  <action>
Add `iterate` command to cli.py that orchestrates render→analyze→play in single call:

1. **Arguments:**
   - `source`: Path OR inline SC code string (positional)
   - `--code/-c`: Flag indicating source is inline code (not a file path)
   - `--duration/-d`: Duration in seconds (required when --code used or file is simple function)
   - `--output/-o`: Output WAV path (default: temp file cleaned up after, or `iterate_NNN.wav` if --keep)
   - `--keep/-k`: Keep WAV file after iterate completes
   - `--no-play`: Skip playback (for automated iteration)
   - `--no-psychoacoustic`: Skip psychoacoustic metrics (faster)
   - `--json/-j`: JSON output (default for this command since Claude is primary user)

2. **Logic:**
   - If `--code` flag: write source to temp .scd file, render, cleanup
   - Else: treat source as file path (existing behavior)
   - Call render module (reuse existing render() function)
   - On success, call analyze module
   - On success and not --no-play, call play module
   - Collect all results into combined output

3. **Output structure (JSON):**
```json
{
  "success": true,
  "render": { /* RenderResult fields */ },
  "analysis": { /* AnalysisResult fields, or null if render failed */ },
  "played": true,
  "output_path": "/path/to/output.wav",
  "total_time_sec": 1.234
}
```

4. **Error handling:**
   - If render fails: return with render error, analysis=null
   - If analysis fails: return with render success, analysis error
   - If play fails: return with render+analysis success, play error

5. **Implementation notes:**
   - Use tempfile for inline code (.scd) and optionally for output (.wav)
   - Human-readable output: summary line + offer to show details
   - Exit codes: 0 success, 1 SC/analysis error, 2 system error
  </action>
  <verify>
```bash
# Test inline code mode
audioloop iterate --code -d 2 "{ SinOsc.ar(440) * 0.3 ! 2 }" --json --no-play

# Test file mode (using existing test fixtures)
audioloop iterate tests/fixtures/simple_function.scd -d 1 --json --no-play

# Verify output structure
audioloop iterate --code -d 1 "{ SinOsc.ar(440) * 0.3 ! 2 }" --json --no-play | python -c "import sys, json; d=json.load(sys.stdin); assert 'render' in d and 'analysis' in d"
```
  </verify>
  <done>
- `audioloop iterate --code -d 2 "{ expr }" --json` renders, analyzes, returns combined JSON
- `audioloop iterate file.scd -d 2 --json` works with file path
- --no-play skips playback, --no-psychoacoustic speeds up analysis
- Exit codes match other commands (0/1/2)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for iterate command</name>
  <files>tests/test_cli.py</files>
  <action>
Add pytest tests for iterate command covering:

1. **Inline code mode:**
   - `--code` with valid simple function
   - `--code` without --duration (should error)
   - Invalid SC syntax (should return render error)

2. **File mode:**
   - Existing simple function file
   - Non-existent file (should error)

3. **Options:**
   - `--no-play` skips playback
   - `--no-psychoacoustic` excludes psychoacoustic metrics from output
   - `--keep` preserves output file
   - `--output` specifies output path

4. **Output validation:**
   - JSON structure has render, analysis, played, output_path, total_time_sec
   - On render failure: analysis is null
   - Exit codes correct

Use typer's CliRunner for testing (already used in test_cli.py).
  </action>
  <verify>pytest tests/test_cli.py -k iterate -v</verify>
  <done>
- Tests cover inline code and file modes
- Tests verify JSON output structure
- Tests verify error handling and exit codes
- All iterate tests pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>audioloop iterate command with inline SC code support</what-built>
  <how-to-verify>
    1. Run: `audioloop iterate --code -d 2 "{ LPF.ar(Saw.ar(200), 800) * 0.3 ! 2 }" --json`
    2. Verify: JSON output contains render and analysis sections
    3. Verify: Audio plays through speakers (warm saw sound)
    4. Run: `audioloop iterate --code -d 1 "{ SinOsc.ar(440) * 0.3 ! 2 }" --no-play --json`
    5. Verify: No audio playback, still get full JSON output
    6. Test error case: `audioloop iterate --code "{ syntax error here" -d 1 --json`
    7. Verify: JSON shows render failure with error message
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `audioloop iterate --help` shows command with all options
- [ ] `audioloop iterate --code -d 1 "{ expr }" --json` returns valid JSON
- [ ] `audioloop iterate file.scd -d 1 --json` works with file paths
- [ ] `pytest tests/test_cli.py -k iterate` passes all tests
- [ ] `--no-play` and `--no-psychoacoustic` flags work correctly
- [ ] Error cases return appropriate exit codes (1 for SC errors, 2 for system errors)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- iterate command reduces multi-command workflow to single invocation
- Claude can use `audioloop iterate --code -d N "{ SC code }" --json` for fast iteration
</success_criteria>

<output>
After completion, create `.planning/phases/5.1-cli-iterate-command/5.1-01-SUMMARY.md` following summary template.
</output>

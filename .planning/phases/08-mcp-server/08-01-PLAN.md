---
phase: 08-mcp-server
plan: 01
type: execute
---

<objective>
Set up MCP infrastructure: dependencies, Pydantic models, async subprocess wrapper, and server skeleton.

Purpose: Establish the foundation for MCP tool implementations with proper async patterns and structured output schemas.
Output: Working FastMCP server skeleton with models matching CLI JSON output schemas.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-mcp-server/08-RESEARCH.md
@src/audioloop/cli.py
@src/audioloop/analyze.py

**Tech stack available:** typer, rich, librosa, MoSQITo, matplotlib
**Established patterns:** Dataclass-based result objects, JSON output from CLI, subprocess management

**From research:**
- Use `mcp>=1.25.0` with FastMCP decorators
- Pydantic models for automatic JSON schema generation
- asyncio subprocess to avoid blocking event loop
- Never print to stdout (reserved for protocol)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MCP dependencies to pyproject.toml</name>
  <files>pyproject.toml</files>
  <action>
Add dependencies to pyproject.toml:
- mcp[cli]>=1.25.0 (official MCP SDK with FastMCP)
- pydantic>=2.0 (for schema generation)

Add to [project.optional-dependencies] as "mcp" group so users can install with `pip install audioloop[mcp]`.

Also add pytest-anyio to dev dependencies for async testing.

Do NOT modify existing dependencies or structure beyond adding these.
  </action>
  <verify>uv sync && python -c "from mcp.server.fastmcp import FastMCP; from pydantic import BaseModel; print('OK')"</verify>
  <done>Dependencies installable and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create Pydantic models matching CLI JSON schemas</name>
  <files>src/audioloop/mcp_models.py</files>
  <action>
Create Pydantic models that match the existing CLI JSON output structure. Reference cli.py for exact field names and types.

Models needed:
1. RenderError - matches error dict in render JSON (message, file, line, char)
2. RenderResult - matches render command JSON output (success, output_path, duration_sec, render_time_sec, mode, error)
3. SpectralFeatures - per-channel spectral data (centroid_hz, rolloff_hz, flatness, bandwidth_hz)
4. TemporalFeatures - attack_ms, rms, crest_factor
5. StereoFeatures - width, correlation
6. PsychoacousticFeatures - loudness_lufs, sharpness_acum, roughness_asper (all Optional since --no-psychoacoustic exists)
7. AnalysisResult - full analysis output matching analyze --json
8. IterateResult - combined render+analysis matching iterate --json
9. ComparisonResult - matching compare --json output

Use Field() with descriptions for better tool schemas. Make fields Optional where the CLI can omit them.

Important: Match the EXACT field names from CLI JSON output - these models must serialize to/from CLI output.
  </action>
  <verify>python -c "from audioloop.mcp_models import RenderResult, AnalysisResult, IterateResult; print('Models imported')"</verify>
  <done>All models importable and match CLI JSON structure</done>
</task>

<task type="auto">
  <name>Task 3: Create async subprocess wrapper and server skeleton</name>
  <files>src/audioloop/mcp_server.py</files>
  <action>
Create the MCP server module with:

1. Async subprocess wrapper `run_cli()`:
   - Use asyncio.create_subprocess_exec to run `sys.executable -m audioloop`
   - Capture stdout and stderr separately
   - Return stdout on success, raise RuntimeError with stderr on failure
   - Accept list of args to pass to audioloop

2. FastMCP server initialization:
   - Create `mcp = FastMCP("audioloop")` (no json_response - we'll return structured models)
   - Add lifespan context manager that verifies audioloop CLI is available on startup
   - Include proper logging to stderr (never stdout)

3. One placeholder tool `@mcp.tool()` that just returns version info (proves wiring works)

Use stderr for all logging. stdout is ONLY for MCP protocol.

Add `if __name__ == "__main__": mcp.run()` entry point.

Reference 08-RESEARCH.md Pattern 2 for subprocess wrapper and Pattern 4 for lifespan.
  </action>
  <verify>python -c "from audioloop.mcp_server import mcp, run_cli; print('Server module OK')"</verify>
  <done>Server skeleton importable, run_cli function exists, placeholder tool defined</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `uv sync` succeeds with new dependencies
- [ ] All Pydantic models import correctly
- [ ] mcp_server.py imports without error
- [ ] `python -m audioloop.mcp_server` starts (may hang waiting for stdin - that's expected)
</verification>

<success_criteria>

- All dependencies installed
- Pydantic models match CLI JSON output schemas
- Async subprocess wrapper ready for tool implementations
- FastMCP server skeleton with lifespan validation
- Entry point works
</success_criteria>

<output>
After completion, create `.planning/phases/08-mcp-server/08-01-SUMMARY.md`
</output>

---
phase: 03-iteration-tools
plan: 01
type: execute
---

<objective>
Add audioloop play command for system audio playback.

Purpose: Enable the listen step of the describe→render→analyze→listen→iterate workflow.
Output: Working `audioloop play <file.wav>` command using macOS afplay.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-iteration-tools/RESEARCH.md
@src/audioloop/cli.py

**From Phase 2:**
- CLI pattern: human-readable default, `--json` flag for JSON output
- Exit codes: 0=success, 1=command error, 2=system error (file not found)
- Error output to stderr via `error_console`

**Tech available:**
- typer, rich (from Phases 1-2)
- subprocess (stdlib)

**Constraining decisions:**
- [Phase 2] Exit code consistency: 0/1/2 pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create play module and CLI command</name>
  <files>src/audioloop/play.py, src/audioloop/cli.py</files>
  <action>
Create src/audioloop/play.py with play_audio() function:
- Takes file_path as Path, validates existence
- Uses subprocess.run() with ["afplay", str(path)]
- Returns None on success, raises PlaybackError on failure
- Keep it simple - no volume/duration options in v1

Add play command to cli.py:
- `audioloop play <file.wav>`
- Validate file exists (exit 2 if not)
- Call play_audio(), catch PlaybackError (exit 1)
- Print "Playing: {file}" before playback starts
- Print "Played: {file}" after completion
- No --json flag needed (nothing to output, just plays audio)

Note: afplay blocks until playback completes - user can Ctrl+C to interrupt.
  </action>
  <verify>
Run: audioloop play tests/fixtures/test_tone.wav
Expected: Plays audio, prints "Playing:" then "Played:" messages
Run: audioloop play nonexistent.wav
Expected: Error message, exit code 2
  </verify>
  <done>
- `audioloop play` command accepts a WAV file path
- Plays audio using afplay on macOS
- Exits 2 for file not found, 1 for playback errors, 0 for success
  </done>
</task>

<task type="auto">
  <name>Task 2: Add play command tests</name>
  <files>tests/test_play.py</files>
  <action>
Create tests/test_play.py with:
1. test_play_existing_file - mock subprocess.run, verify afplay called
2. test_play_nonexistent_file - verify exit code 2
3. test_play_cli_output - verify "Playing:" and "Played:" messages

Use mocker.patch("subprocess.run") to avoid actual audio playback in tests.
Use tests/fixtures/test_tone.wav (exists from Phase 2) as test file.
  </action>
  <verify>
Run: cd /Users/morgan/code/audio-loop && python -m pytest tests/test_play.py -v
Expected: All tests pass
  </verify>
  <done>
- Tests cover successful playback (mocked), file not found, and CLI output
- All tests pass
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `audioloop play tests/fixtures/test_tone.wav` plays audio
- [ ] `audioloop play nonexistent.wav` exits with code 2
- [ ] `python -m pytest tests/test_play.py -v` passes
- [ ] `audioloop --help` shows play command
</verification>

<success_criteria>
- audioloop play command works end-to-end
- Exit codes follow established pattern (0/1/2)
- Tests pass
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/03-iteration-tools/03-01-SUMMARY.md`
</output>
